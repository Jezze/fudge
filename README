# FUDGE

## ABOUT

Fudge is a powerful yet elegant operating system written by Jens Nyberg. It
started as a hobby somewhere around early 2009 but has since grown to become
quite useful. Even if it takes a lot of inspiration from other operating
systems Fudge is fundamentally different in many aspects and tries to
incorporate new and unusual ideas.

Keywords for this project is simplicity, clarity and speed.

* Deterministic behaviour
One of the main goals of Fudge is to be as deterministic as possible. This is
not the same as a realtime operating system that tries to finish workloads
within given timelimits but deterministic in the sense that running one task
multiple times will always take the same amount of time. Fudge tries to
accomplish this by replacing various parts normally found in most operating
systems that isn't deterministic in nature such as memory allocation and
multitasking. Not only does this make the system more deterministic but also
less complex because of the decreased amount of states the operating system can
exist in which makes it both easier to analyze and less complex to write.

* No multitasking
There is no scheduling or timeslices to consider. Fudge is designed to work on
one task at a time. This does not mean Fudge is limited to run only one program
at a time. To have multiple programs working in unison Fudge uses an event
system that let programs delay their own execution until a specific event
occurs, like when data is ready to be read from a disk, and will register a
callback that takes precedence over the program currently running. Events are
triggered both by system calls and interrupt requests. Using this method it is
even possible to construct a multitasking scenario by simply listening on the
internal clock.

* Terminate and stay resident
In Fudge a user space program is not encouraged to run busy waits. Instead they
should issue a certain system call as soon as it is not working on anything or
waiting for some sort of external event. No matter the type of operating system
a typical program is for the most part in a waiting state. Because of how Fudge
works it can look at all the running programs and see that all are in a waiting
state and simple put the CPU to halt. This basically means, in a somewhat
simplified example, that your computer is only running from the time you hit a
key until you release it again. The rest of the time it is off.

* No memory allocation
It is not possible to dynamically allocate memory at runtime. In this way Fudge
will never be out of memory and the kernel will be less occupied with
allocating and deallocating memory. All preallocated areas of RAM will show up
as files in the virtual filesystem.

* No directory structure
Fudge virtual filesystem does not have directories in the classical sense.
Instead it has views which is simular to what a branch is in git. This has a
lot of advantages because you never have to think about where one file exist in
relation to another and if you should use relative or absolute paths to
reference it. It is very intuitive from a user standpoint.

## FEATURES

I have a long way to go but these are the features I've implemented so far.
Some of them might be incomplete at the moment but they exist in one way or another.

Kernel:
* Multi-architectural code
* Memory protection using paging
* Virtual filesystem interface
* ELF binary support incl. relocation
* TAR ramdisk support

Drivers:
* VGA support
* Serial support
* PIT support
* RTC support
* FPU support
* PCI support
* ATA support (lba read-only)
* Ext2 detection
* Bochs graphics adapter
* PS/2 keyboard
* PS/2 mouse
* RTL8139 network card
* TTY devices

## BUILDING

NOTE: The ARM port is not working at the moment so this is for x86 only.

### PREREQUISITIES

To try Fudge you need a Unix compatible system like Linux or *BSD. It might
work on Windows if you have cygwin installed but this has not been tested.

To compile and run Fudge you need to have the following tools installed.

* nasm (compile assembler code)
* dd (to create disk image)
* genisoimage (to create cd image)
* qemu or bochs (emulator)

### FETCHING

Download the source using git.

$ git clone git://github.com/Jezze/fudge.git fudge

### COMPILING

First you need to create the cross compilation tools.

$ cd fudge
$ export PATH=$PATH:/path/to/fudge/toolchain/local/bin
$ make toolchain

Compile fudge.

$ make

Create an iso image.

$ make iso

### RUNNING

$ qemu[-system-x86] -cdrom fudge.iso

### CLEANING

This will remove all fudge content but leave the cross compilation tools
intact so you don't need to compile that again.

$ make clean

