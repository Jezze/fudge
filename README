FUDGE
=====

ABOUT
-----

Fudge is a very basic operating system written in C and Assembler. It is inspired by many other projects like Minix, Plan9, L4 and AmigaOS but Fudge is fundamentally different in many aspects.

Keywords for this project is simplicity, clearity and speed.

At the moment I’m trying to figure out what direction I want this project to go so nothing is so far written in stone. However, it will feature some ideas that are very uncommon in other mainstream operating systems. Wether they are bad ideas or in practice doesn’t actually work is of no concern to me. I still want to see what I’m able to do when thinking outside the box. Here are some brief examples.

* Deterministic behaviour
The main goal of this operating system is to be as determinstic as possible. This is not the same as a real-time operating system that only need to finish workloads within a given timelimit. I’m talking about the actual computation time. I’m trying to accomplish this by removing those parts of a typical operating system that often provides uncertainty such as memory allocation and multitasking to name a few. It not only becomes more deterministic but also less complex because the amount of states in the operating system is lower which makes it easier to predict.

* No multitasking
There will be no scheduler or timeslices to consider. Instead I’ve chose to use something I call event-driven sequence-tasking. This works by letting every system call trigger a certain event. Any program can attach listeners to these events that will execute when the events are fired. As an example I could attach a listener to the event that fires when the system call call_file_close() is triggered for a certain file. If a program writes to that file and closes it the newly added listener would fire and start an eventhandler that in turn could execute a new program that reads the contents of the file.

* No memory allocation
It is not possible to dynamically allocate memory in run-time. All memory has to be pre-allocated when the operating system starts. In this way there will never be a chance of memory running out and the kernel would be less occupied with allocating and deallocating memory. All pre-allocated areas of RAM will show up as files in the virtual filesystem. If one of these files become full something needs to take care of the written data before more data can be written.

* Static paging
Because only one program can run at a time and the amount of memory the entire operating system uses can not exceed the amount of physical RAM there is no need to fetch or store pages to frames or disk. Therefor there are only two page directories set up. One for the kernel and one for any current running program. The kernel page directory runs in kernel space and any program runs in userspace so memory protection do exist to prevent programs to override kernel data.
                                        
FEATURES
--------

I have a long way to go but these are the features I’ve implemented so far. Some of them might not work or are incomplete at the moment but they exist in one way or another.

* Boot and setup code
* Multi-architectural code – Full x86 and basic ARM support
* Interrupts
* Paging
* FPU support
* System calls
* Screen output
* Keyboard input
* Serial port communication
* Programmable interval timer
* Real time clock
* Virtual filesystem
* stdin and stdout
* Tar ramdisk (NEW)
* Flat binary support
* ELF binary support

INSTALL
-------

NOTE: The ARM port is not working at the moment so this is for x86 only.

PREREQUISITIES

To try Fudge you need a Unix compatible system like Linux or *BSD. It might work on Windows if you have cygwin installed but this has not been tested.

To compile and run Fudge you need to have the following tools installed.

* nasm (compile assembler code)
* gcc or clang (compile C code)
* ld (linker)
* dd (to create disk image)
* genisoimage (to create cd image)
* qemu or bochs (emulator)

FETCHING

Download the source either directly or by using git.

$ git clone git://github.com/Jezze/fudge.git fudge

COMPILING

$ cd build
$ sh x86-make.sh

If everything went well these files should have appeared:

build/root/boot/kernel
build/root/boot/initrd.tar

Alt 1. Create image and run in Qemu

$ sh x86-create-image.sh
$ sh x86-qemu-image.sh

Alt 2. Create iso and run in Qemu

$ sh x86-create-iso.sh
$ sh x86-qemu-iso.sh

CLEANING

This will remove all post-compiled content.

$ sh clean.sh

