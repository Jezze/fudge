# FUDGE

## ABOUT

Fudge is a small and elegant operating system. It started as a project to see if
it would be possible to create an operating system that came as close as
possible to be fully deterministic. Today, operating systems often show
unpredictable behaviour because they implement technical solutions that are not
determinstic in nature such as task scheduling, caching and dynamic memory
allocation. Fudge tries to find alternative solutions to these problems and has
so far been found to work quite well.

Determinism in the term of computers could mean many different things. It could
mean that a program, given input, should always return a conclusive result.
However unlikely that sounds it is actually quite common because of unwanted
side-effects such as time delays or incorrectly handled input. Determinism could
also mean that every time you execute a program it will always take the same
amount of time to complete given the same input and the same environment in
which it operates.

Fudge focus is on the latter where each programs should complete in the same
amount of time or as close as possible. This is not to be confused with a
real-time operating system that is only concerned about making sure each task is
guaranteed a certain amount of time. Here instead we are concerned with the
actual execution time. In order to achieve this Fudge will only run one task at
a time and will not interrupt the running task unless an interrupt occurs from
hardware or software. This does not mean that Fudge is limited to only run one
task at a time because tasks can delay there own execution until such an
interrupt occurs and take presedence if the interrupt is of the type it was
waiting for. While Fudge operates in kernel mode it can not be interrupted at
all so the kernel in that sense is fully deterministic. The kernel also does not
keep track of things in a dynamic fashion so each interrupt of the same type
should always take the exact same time as any previous. The kernel is not even
aware of the fact there can be many tasks running because it can only see the
current running one.

## BUILDING

### PREREQUISITIES

To try Fudge you need a Unix compatible system like Linux or *BSD. It might work
on Windows if you have cygwin installed but this has not been tested.

To compile and run Fudge you need to have the following tools installed.

    * clang (compile and link)
    * qemu or bochs (emulator)

### FETCHING

Download the source using git.

    $ git clone git://github.com/Jezze/fudge.git fudge

### BUILDING

At the moment Fudge only runs properly on x86 using a multiboot compliant loader
but there are other loaders and architectures under development.

To compile for x86 you write:

    $ make

To clean for x86 you write:

    $ make clean

To compile for ARM you write:

    $ make ARCH=arm LOADER=versatilepb

To clean for ARM you write:

    $ make ARCH=arm LOADER=versatilepb clean

It is possible to edit the Makefile and set the ARCH and LOADER variable
directly so you don't need to supply it every time you compile.

## RUNNING IN QEMU

The simplest way is to run it inside qemu:

    $ qemu-system-x86 -kernel fudge -initrd initrd.tar

Possible extra options that fudge supports:

    -serial stdio
    -vga std
    -net nic,model=rtl8139 -net tap,script=no,downscript=no,ifname=tap0

If you have built for ARM just replace x86 with arm.

## RUNNING ON REAL HARDWARE

If you use Grub add an entry to menu.lst:

    title  Fudge
    root   (hd0,0)
    kernel /fudge
    module /initrd.tar

If you use Grub 2 add an entry to grub.cfg:

    menuentry "Fudge" {
        multiboot /fudge
        module /initrd.tar
        boot
    }

Then as root you can execute:

    $ make install [ INSTALL_PATH=/boot ]

This will copy fudge and initrd.tar to your /boot folder
