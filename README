# FUDGE

## ABOUT

Fudge is a small and elegant operating system. It started as a project to see if
it would be possible to create an operating system that came as close as
possible to be fully deterministic. Today, operating systems often show
unpredictable behaviour because they implement technical solutions that are not
determinstic in nature such as task scheduling, caching and dynamic memory
allocation. Fudge tries to find alternative solutions to these problems and has
so far been found to work quite well.

### Determinism

Determinism in the term of computers could mean many different things. It could
mean that a program, given input, should always return a conclusive result.
However unlikely that sounds it is actually quite common because of unwanted
side-effects such as time delays or incorrectly handled input. Determinism could
also mean that every time you execute a program it will always take the same
amount of time to complete given the same input and the same environment in
which it operates.

Fudge focus is on the latter where each programs should complete in the same
amount of time or as close as possible. This is not to be confused with a
real-time operating system that is only concerned about making sure each task is
guaranteed a certain amount of time. Here instead we are concerned with the
actual execution time. In order to achieve this Fudge will only run one task at
a time and will not interrupt the running task unless an interrupt occurs from
hardware or software. This does not mean that Fudge is limited to only run one
task at a time because tasks can delay there own execution until such an
interrupt occurs and take presedence if the interrupt is of the type it was
waiting for. While Fudge operates in kernel mode it can not be interrupted at
all so the kernel in that sense is fully deterministic. The kernel also does not
keep track of things in a dynamic fashion so each interrupt of the same type
should always take the exact same time as any previous. The kernel is not even
aware of the fact there can be many tasks running because it can only see the
current running one.

## BUILDING

### PREREQUISITIES

To try Fudge you need a Unix compatible system like Linux or *BSD. It might work
on Windows if you have cygwin installed but this has not been tested.

To compile and run Fudge you need to have the following tools installed.

* binutils (assembly linker)
* gcc or clang (compile c)
* dd (to create disk image)
* genisoimage (to create cd image)
* qemu or bochs (emulator)

### FETCHING

Download the source using git.

$ git clone git://github.com/Jezze/fudge.git fudge

### BUILDING

At the moment Fudge only runs properly on x86 but there is an ARM port under
development. It is very limited at the moment.

Depending on what architecture and compiler you use you can edit the top
Makefile and change the ARCH and PREFIX settings.

The default is:

ARCH=x86
PREFIX=

If you want to compile for ARM with arm-eabi- you can change to:

ARCH=arm
PREFIX=arm-eabi-

Then you only need to run make in order to compile.

$ make

These settings can also be applied without modifing the Makefile:

$ make ARCH=arm PREFIX=arm-eabi-

### CLEANING

With modified makefile:

$ make clean

Without a modified makefile:

$ make ARCH=arm clean

## RUNNING IN QEMU

### x86 EXAMPLES

With GRUB image:

$ qemu-system-x86 -cdrom fudge.iso -vga std

With QEMU bootloader:

$ qemu-system-x86 -kernel image/boot/fudge -initrd image/boot/initrd.tar -vga std

### ARM EXAMPLES

With QEMU bootloader:

$ qemu-system-arm -kernel image/boot/fudge -initrd image/boot/initrd.tar -serial stdio

