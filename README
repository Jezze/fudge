# FUDGE

## ABOUT

Fudge is a very basic operating system written in C and Assembler. It is inspired by many other projects like Minix, Plan9, L4 and AmigaOS but Fudge is fundamentally different in many aspects.

Keywords for this project is simplicity, clarity and speed.

At the moment I’m trying to figure out what direction I want this project to go so nothing is so far written in stone. I know for sure it will feature some ideas that are uncommon in other mainstream operating systems. Even if those features might seem awkward I still want to see what can be done when thinking outside the box. Here are some brief examples.

* Deterministic behaviour
The main goal of this operating system is to be as deterministic as possible. This is not the same as a realtime operating system that only need to finish workloads within a given timelimit. I’m talking about the actual computation time. I’m trying to accomplish this by replacing various parts of a typical operating system that isn't deterministic in nature such as memory allocation and multitasking. Not only does that make the system more deterministic but also less complex because the decreased amount of states the operating system can exist in which makes it both easier to analyze and less complex to write.

* No multitasking
There will be no scheduler or timeslices to consider. Instead I’ve chose to use something I call event-driven sequence-tasking. This works by letting every system call trigger events. Any program can attach listeners to these events, basically a callback, that will execute when the events are fired. As an example a program could attach a listener to an event that will fire when a certain file is closed. If a second program is writing to that file and when done closes it the first program will get an event that tells it the file has been closed and can now opened for reading.

* No memory allocation
It is not possible to dynamically allocate memory in runtime. All memory has to be preallocated when the operating system starts. In this way there will never be a chance of memory running out and the kernel would be less occupied with allocating and deallocating memory. All preallocated areas of RAM will show up as files in the virtual filesystem. If one of these files becomes full it's content needs to be taken care of before more data can be written.

* No directories
Fudge does not have directories in the classical sense. Instead it has views which works simular like branches in git. This has a lot of advantages because you never have to think about where one file exist in relation to another and if you should use relative or absolute paths to reference it. The fopen(char *path) call in posix would be file_open(char *view, char *name) in fudge. No paths to worry about. It is actually very intuitive and I feel it goes a lot faster.

## FEATURES

I have a long way to go but these are the features I’ve implemented so far. Some of them might be incomplete at the moment but they exist in one way or another.

Kernel:
* Multi-architectural code
* Memory protection using paging
* Virtual filesystem interface
* ELF binary support incl. relocation
* TAR ramdisk support

Drivers:
* VGA support
* Serial support
* PIT support
* RTC support
* FPU support
* PCI support
* ATA support (lba28 read-only)
* Ext2 support
* BGA graphics support
* PS/2 keyboard
* PS/2 mouse
* RTL8139 network card
* TTY devices

## BUILDING

NOTE: The ARM port is not working at the moment so this is for x86 only.

### PREREQUISITIES

To try Fudge you need a Unix compatible system like Linux or *BSD. It might work on Windows if you have cygwin installed but this has not been tested.

To compile and run Fudge you need to have the following tools installed.

* nasm (compile assembler code)
* gcc or clang (compile C code)
* ld (linker)
* dd (to create disk image)
* genisoimage (to create cd image)
* qemu or bochs (emulator)

### FETCHING

Download the source either directly or by using git.

$ git clone git://github.com/Jezze/fudge.git fudge

### COMPILING

$ make

If everything went well these files should have appeared:

build/root/boot/kernel
build/root/boot/initrd.tar

Create an iso.

$ make iso

### RUNNING

$ qemu -cdrom fudge.iso [-serial stdio] [-net nic,model=rtl8139]

### CLEANING

This will remove all post-compiled content.

$ make clean

