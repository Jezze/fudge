# FUDGE

## ABOUT

Fudge is a very basic operating system written in C and Assembler. It is inspired by many other projects like Minix, Plan9, L4 and AmigaOS but Fudge is fundamentally different in many aspects.

Keywords for this project is simplicity, clearity and speed.

At the moment I’m trying to figure out what direction I want this project to go so nothing is so far written in stone. However, it will feature some ideas that are very uncommon in other mainstream operating systems. Wether they are bad ideas or in practice doesn’t actually work is of no concern to me. I still want to see what I’m able to do when thinking outside the box. Here are some brief examples.

* Deterministic behaviour
The main goal of this operating system is to be as determinstic as possible. This is not the same as a real-time operating system that only need to finish workloads within a given timelimit. I’m talking about the actual computation time. I’m trying to accomplish this by removing those parts of a typical operating system that often provides uncertainty such as memory allocation and multitasking to name a few. It not only becomes more deterministic but also less complex because the amount of states in the operating system is lower which makes it easier to predict.

* No multitasking
There will be no scheduler or timeslices to consider. Instead I’ve chose to use something I call event-driven sequence-tasking. This works by letting every system call trigger a certain event. Any program can attach listeners to these events that will execute when the events are fired. As an example I could attach a listener to the event that fires when the system call call_file_close() is triggered for a certain file. If a program writes to that file and closes it the newly added listener would fire and start an eventhandler that in turn could execute a new program that reads the contents of the file.

* No memory allocation
It is not possible to dynamically allocate memory in run-time. All memory has to be pre-allocated when the operating system starts. In this way there will never be a chance of memory running out and the kernel would be less occupied with allocating and deallocating memory. All pre-allocated areas of RAM will show up as files in the virtual filesystem. If one of these files become full something needs to take care of the written data before more data can be written.

## FEATURES

I have a long way to go but these are the features I’ve implemented so far. Some of them might not work or are incomplete at the moment but they exist in one way or another.

* Multi-architectural code
* Memory protection
* VGA framebuffer
* PS2 keyboard
* Serial ports
* PIT support
* RTC support
* FPU support
* VFS filesystem
* ELF binary support
* TAR ramdisk support
* ATA detection
* PCI devices
* TTY devices
* Module interface
* Device interface
* Driver interface

## BUILDING

NOTE: The ARM port is not working at the moment so this is for x86 only.

### PREREQUISITIES

To try Fudge you need a Unix compatible system like Linux or *BSD. It might work on Windows if you have cygwin installed but this has not been tested.

To compile and run Fudge you need to have the following tools installed.

* nasm (compile assembler code)
* gcc or clang (compile C code)
* ld (linker)
* dd (to create disk image)
* genisoimage (to create cd image)
* qemu or bochs (emulator)

### FETCHING

Download the source either directly or by using git.

$ git clone git://github.com/Jezze/fudge.git fudge

### COMPILING

$ make

If everything went well these files should have appeared:

build/root/boot/kernel
build/root/boot/initrd.tar

Create an iso.

$ make iso

### RUNNING

$ qemu -cdrom fudge.iso [-serial stdio] [-net nic,rtl8139]

### CLEANING

This will remove all post-compiled content.

$ make clean

