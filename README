# FUDGE

## ABOUT

Fudge is a very basic operating system written in C and Assembler. It is inspired by many other projects like Minix, Plan9, L4 and AmigaOS but Fudge is fundamentally different in many aspects.

Keywords for this project is simplicity, clarity and speed.

At the moment I’m trying to figure out what direction I want this project to go so nothing is so far written in stone. I know for sure it will feature some ideas that are uncommon in other mainstream operating systems. Even if those features might seem awkward I still want to see what can be done when thinking outside the box. Here are some brief examples.

* Deterministic behaviour
The main goal of this operating system is to be as determinstic as possible. This is not the same as a real-time operating system that only need to finish workloads within a given timelimit. I’m talking about the actual computation time. I’m trying to accomplish this by removing those parts of a typical operating system that isn't deterministic in nature such as memory allocation and multitasking to name a few. Not only does that make the system more deterministic but also less complex because the of the decreased amount of states the operating system has which makes it easier to analyze and write correct code.

* No multitasking
There will be no scheduler or timeslices to consider. Instead I’ve chose to use something I call event-driven sequence-tasking. This works by letting every system call trigger events. Any program can attach listeners to these events, basically a callback, that will execute when the events are fired. As an example I a program could attach a listener to an event that will fire when a certain file is closed. If a second program is writing to that file and when done closes it the first program will get an event that tells it the file has been closed and can now opened for reading.

* No memory allocation
It is not possible to dynamically allocate memory in run-time. All memory has to be pre-allocated when the operating system starts. In this way there will never be a chance of memory running out and the kernel would be less occupied with allocating and deallocating memory. All pre-allocated areas of RAM will show up as files in the virtual filesystem. If one of these files become full it's content needs to be taken care of before more data can be written.

## FEATURES

I have a long way to go but these are the features I’ve implemented so far. Some of them might not work or are incomplete at the moment but they exist in one way or another.

* Multi-architectural code
* Memory protection
* VGA framebuffer
* PS2 keyboard
* Serial ports
* PIT support
* RTC support
* FPU support
* VFS filesystem
* ELF binary support
* TAR ramdisk support
* ATA detection
* PCI devices
* TTY devices
* Module interface
* Device interface
* Driver interface

## BUILDING

NOTE: The ARM port is not working at the moment so this is for x86 only.

### PREREQUISITIES

To try Fudge you need a Unix compatible system like Linux or *BSD. It might work on Windows if you have cygwin installed but this has not been tested.

To compile and run Fudge you need to have the following tools installed.

* nasm (compile assembler code)
* gcc or clang (compile C code)
* ld (linker)
* dd (to create disk image)
* genisoimage (to create cd image)
* qemu or bochs (emulator)

### FETCHING

Download the source either directly or by using git.

$ git clone git://github.com/Jezze/fudge.git fudge

### COMPILING

$ make

If everything went well these files should have appeared:

build/root/boot/kernel
build/root/boot/initrd.tar

Create an iso.

$ make iso

### RUNNING

$ qemu -cdrom fudge.iso [-serial stdio] [-net nic,rtl8139]

### CLEANING

This will remove all post-compiled content.

$ make clean

